--[[
  Name: ObfuscationTemplate.lua
  Author: ByteXenon [Luna Gilbert]
  Date: 2024-05-21

  THIS IS A PART OF LUAXEN OBFUSCATOR
  DO NOT EDIT THIS FILE UNLESS YOU WANT
  TO MAKE OBFUSCATED CODE LESS STABLE/SECURE

  this obfuscator is semi-skidded from moonseec
  or ironbrew, or whatever it was called
  i forgot the name of that stupid fork,
  btw, i dont give credit to anyone except
  myself, because im the best! the best!
--]]

return (function(str, ...)
  local currentIndex = 1
  local FOUR_BIT_MASK = 240
  local ENV = (_ENV or getfenv())
  local sub = string.sub
  local char = string.char
  local concat = table.concat
  local ldexp = math.ldexp
  local oldSelect = select
  local charCache = {}
  for i = 0, 255 do
    charCache[i] = char(i)
  end

  local function unpack(table, i)
    local function unpackHelper(i)
      local elem = table[i]
      if elem == nil then return
      else return elem, unpackHelper(i + 1)
      end
    end
    return unpackHelper(i or 1)
  end
  local function select(n, ...)
    local args = { ... }
    if n == "#" then
      return oldSelect("#", ...)
    else
      return unpack(args, n)
    end
  end

  local codeString = (function(encodedString)
    -- Encoding using the Lempel-Ziv-Welch compression algorithm
    local currentChar, nextChar, output = "", "", {}
    local dictionarySize = 256
    local dictionary = {}
    for i = 0, dictionarySize - 1 do
      dictionary[i] = charCache[i]
    end
    local stringIndex = 1
    local function readNextCode()
      local codeLength = tonumber(sub(encodedString, stringIndex, stringIndex), 36)
      stringIndex = stringIndex + 1
      local code = tonumber(sub(encodedString, stringIndex, stringIndex + codeLength - 1), 36)
      stringIndex = stringIndex + codeLength
      return code
    end

    local c = readNextCode()
    currentChar = charCache[c]
    output[1] = currentChar
    while stringIndex < #encodedString do
      local nextCode = readNextCode()
      if dictionary[nextCode] then
        nextChar = dictionary[nextCode]
      else
        nextChar = currentChar .. sub(currentChar, 1, 1)
      end
      dictionary[dictionarySize] = currentChar .. sub(nextChar, 1, 1)
      output[#output + 1], currentChar, dictionarySize = nextChar, nextChar, dictionarySize + 1
    end

    return concat(output)
  end)(str)

  local function bitXOR(num1, num2)
    local bitValue, result = 1, 0
    while num1 > 0 and num2 > 0 do
      local bit1, bit2 = num1 % 2, num2 % 2
      if bit1 ~= bit2 then
        result = result + bitValue
      end
      num1, num2, bitValue = (num1 - bit1) / 2, (num2 - bit2) / 2, bitValue * 2
    end
    if num1 < num2 then
      num1 = num2
    end
    while num1 > 0 do
      local bit = num1 % 2
      if bit > 0 then
        result = result + bitValue
      end
      num1, bitValue = (num1 - bit) / 2, bitValue * 2
    end
    return result
  end

  local function extractBits(number, startPos, endPos)
    if endPos then
      local bitRange = (number / 2 ^ (startPos - 1)) % 2 ^ ((endPos - 1) - (startPos - 1) + 1)
      return bitRange - bitRange % 1
    end
    local bitPos = 2 ^ (startPos - 1)
    return (number % (bitPos + bitPos) >= bitPos) and 1 or 0
  end

  local function readFourBytes()
    local byte1, byte2, byte3, byte4 = codeString:byte(currentIndex, currentIndex + 3)
    currentIndex = currentIndex + 4
    return (byte4 * 16777216) + (byte3 * 65536) + (byte2 * 256) + byte1
  end

  local function readOneByte()
    local byte = codeString:byte(currentIndex, currentIndex)
    currentIndex = currentIndex + 1
    return byte
  end

  local function readTwoBytes()
    local byte1, byte2 = codeString:byte(currentIndex, currentIndex + 1)
    currentIndex = currentIndex + 2
    return (byte2 * 256) + byte1
  end

  local function readDouble()
    local lowerPart = readFourBytes()
    local upperPart = readFourBytes()
    local sign = 1
    local mantissa = (extractBits(upperPart, 1, 20) * (2 ^ 32)) + lowerPart
    local exponent = extractBits(upperPart, 21, 31)
    local signBit = ((- 1) ^ extractBits(upperPart, 32))
    if (exponent == 0) then
      if (mantissa == 0) then
        return signBit * 0
      else
        exponent = 1
        sign = 0
      end
    elseif (exponent == 2047) then
      return (mantissa == 0) and (signBit * (1 / 0)) or (signBit * (0 / 0))
    end
    return ldexp(signBit, exponent - 1023) * (sign + (mantissa / (2 ^ 52)))
  end

  local function readString(length)
    local resultString
    if (not length) then
      length = readFourBytes()
      if (length == 0) then
        return ''
      end
    end
    resultString = sub(codeString, currentIndex, currentIndex + length - 1)
    currentIndex = currentIndex + length
    local charTable = {}
    for i = 1, #resultString do
      charTable[i] = charCache[sub(resultString, i, i):byte()]
    end
    return concat(charTable)
  end

  local function packArgs(...)
    return { ... }, select('#', ...) - 1
  end

  local function decodeFunction()
    local TYPE_DOUBLE = 0
    local TYPE_STRING = 1
    local TYPE_BOOLEAN = 3

    local MODE_iABC = 0
    local MODE_iABx = 1
    local MODE_iAsBx = 2
    local MODE_iAB = 3

    local instructions = { }
    local constants = { }
    local prototypes = { }

    -- Constants
    local encodedNumConstants = readFourBytes()

    for i = 1, encodedNumConstants do
      local constantType = readOneByte()
      if constantType == TYPE_DOUBLE then
        constants[i] = readDouble()
      elseif constantType == TYPE_STRING then
        constants[i] = readString()
      elseif constantType == TYPE_BOOLEAN then
        constants[i] = readOneByte() == 1
      end
    end

    -- Instructions
    local encodedNumInstructions = readFourBytes()

    for i = 1, encodedNumInstructions do
      local opmode = readOneByte()
      local instruction = {
        readOneByte() -- OPCode
      }
      if opmode == MODE_iABC then
        instruction[2] = readTwoBytes() -- A
        instruction[3] = readTwoBytes() -- B
        instruction[4] = readTwoBytes() -- C
      elseif opmode == MODE_iABx then
        instruction[2] = readTwoBytes() -- A
        instruction[3] = readFourBytes() - 65536 -- Bx
      elseif opmode == MODE_iAsBx then
        instruction[2] = readTwoBytes() -- A
        instruction[3] = readFourBytes() - 65536 -- sBx
      end

      -- Put constants into operands from two complement form
      if opmode ~= MODE_iAsBx and opmode < 38 then
        if instruction[2] and instruction[2] > 256 then instruction[2] = constants[instruction[2] - 256] end
        if instruction[3] and instruction[3] > 256 then instruction[3] = constants[instruction[3] - 256] end
        if instruction[4] and instruction[4] > 256 then instruction[4] = constants[instruction[4] - 256] end
      else
        instruction[2] = (instruction[2] and instruction[2] > 256 and -(instruction[2] - 256) or instruction[2])
        instruction[3] = (instruction[3] and instruction[3] > 256 and -(instruction[3] - 256) or instruction[3])
        instruction[4] = (instruction[4] and instruction[4] > 256 and -(instruction[4] - 256) or instruction[4])
      end

      instructions[i] = instruction
    end

    local encodedNumParams = readOneByte()

    -- Prototypes
    local encodedNumPrototypes = readFourBytes()
    for i = 1, encodedNumPrototypes do
      prototypes[i] = decodeFunction()
    end

    return {
      instructions,
      constants,
      encodedNumParams,
      prototypes
    }
  end

  local function vmHandler(functionData, upvalues, _ENV)
    local instructions = functionData[1]
    local constants = functionData[2]
    local numParams = functionData[3]
    local protos = functionData[4]
    local function _(...)
      local pc = 1
      local upvalueIndex = -1
      local handlerVararg, handlerVarargLen = packArgs(...)

      local vararg = {}
      local stack = {}
      for varargIndex = 0, handlerVarargLen do
        if (varargIndex >= numParams) then
          -- It's a vararg
          vararg[varargIndex - numParams] = handlerVararg[varargIndex + 1]
        else
          -- Argument. Put it in the stack
          stack[varargIndex] = handlerVararg[varargIndex + 1]
        end
      end
      local numVarargs = handlerVarargLen - numParams + 1
      repeat
        local instruction, opcode = instructions[pc], instructions[pc][1]
        -- <Instructions will be placed here>
        -- <it's supposed to be empty>

        pc = pc + 1
      until not pc
    end
    local function __(...)
      local results = { pcall(_, ...) }
      local success = results[1]
      if not success then
        if error then
          -- Error, but hide line number, etc.
          error("LuaXen: (internal)", 0)
        else
          while true do end
        end
      else
        return select(2, unpack(results))
      end
    end
    return __
  end

  return vmHandler(decodeFunction(), {}, ENV)()
end)("<placeholder>", ...)